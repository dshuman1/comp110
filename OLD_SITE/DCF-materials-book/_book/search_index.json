[
["more-transformation-verbs.html", "§ 22 More transformation verbs 22.1 Rank transforms 22.2 Leads and lags 22.3 Times and Dates 22.4 Conditional transforms 22.5 Text", " § 22 More transformation verbs Recall that a transformation verb takes a variable as an input and produces a variable of the same length as the output. Some familiar transformation verbs from primary and secondary school: arithmetic operations (+, -, /, *) mathematical functions such as logs and exponentiation There are additional transformations which will be unfamiliar, simply because they did not fit into the algebra- and trigonometry-based high-school curriculum Rank transforms Lead and lag transforms Date transforms Conditional transforms Character transforms 22.1 Rank transforms Many questions take forms such as these: “Find the largest …” “Find the three largest …” “Find the smallest within each group …” The functions min() and max() are reduction verbs. They tell you the single lowest or highest value in a set. Because they are reduction verbs, they are often used in summarise(), which reduces a set of cases to a single case. BabyNames %&gt;% group_by(sex) %&gt;% summarise(most_popular = max(count)) ## # A tibble: 2 × 2 ## sex most_popular ## &lt;chr&gt; &lt;int&gt; ## 1 F 99674 ## 2 M 94758 Notice that name was not carried along. When you summarise(), the only variables that appear in the output are the grouping variables, and the variables you create through the arguments to summarise(). If you wanted to know the names that are most popular, you will need to rely on filter(). Get rid of the cases that are not the most popular. BabyNames %&gt;% group_by(sex) %&gt;% filter(count == max(count)) ## Source: local data frame [2 x 4] ## Groups: sex [2] ## ## name sex count year ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Linda F 99674 1947 ## 2 James M 94758 1947 Filter() needs a criterion. The criterion count == max( count ) (with the double equals sign ==) passes through the case where the value of count matches the largest value of count. That will be the biggest case. BabyNames %&gt;% group_by(sex) %&gt;% filter(count &gt; 0.90 * max(count)) ## Source: local data frame [28 x 4] ## Groups: sex [2] ## ## name sex count year ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 James M 87428 1946 ## 2 Linda F 99674 1947 ## 3 James M 94758 1947 ## 4 Robert M 91652 1947 ## 5 John M 88318 1947 ## 6 Linda F 96210 1948 ## 7 James M 88610 1948 ## 8 Robert M 85492 1948 ## 9 Linda F 90994 1949 ## 10 James M 86779 1949 ## # ... with 18 more rows Note: Almost all of these are from the late 1940s and early 1950s. In part, this reflects the baby boom. Perhaps it also reflects the conformity that people associate with that era. QUESTION: How would you estimate “conformity” for each year? Possibility: Take the 10 most popular names each year. Find out what fraction of the total number of births that was. The rank() operation is helpful here. The rank() function does something simple but powerful: it replaces each number in a set with where that number stands with respect to the others. For instance, look at the tiny data table Set shown in Table . What’s the rank of the number 5 in the numbers variable. Set &lt;- data.frame(numbers = as.integer(c(2, 5, 4, 7, 2, 9, 9, 8))) Set %&gt;% mutate(the_rank = rank(numbers)) ## numbers the_rank ## 1 2 1.5 ## 2 5 4.0 ## 3 4 3.0 ## 4 7 5.0 ## 5 2 1.5 ## 6 9 7.5 ## 7 9 7.5 ## 8 8 6.0 Or, seen another way Set %&gt;% mutate(the_rank = rank(numbers)) %&gt;% arrange(numbers) ## numbers the_rank ## 1 2 1.5 ## 2 2 1.5 ## 3 4 3.0 ## 4 5 4.0 ## 5 7 5.0 ## 6 8 6.0 ## 7 9 7.5 ## 8 9 7.5 Notice how ties are broken. Also note that the biggest numbers have the highest ranks. This is different than the convention in everyday language, where the “Number 1 ranked team” is the best team. To follow this convention, use rank(desc(numbers)). Set %&gt;% mutate(the_rank = rank(desc(numbers))) %&gt;% arrange(numbers) ## numbers the_rank ## 1 2 7.5 ## 2 2 7.5 ## 3 4 6.0 ## 4 5 5.0 ## 5 7 4.0 ## 6 8 3.0 ## 7 9 1.5 ## 8 9 1.5 Suppose you want to find the 3rd most popular name of all time. Use rank(). BabyNames %&gt;% group_by(name) %&gt;% summarise(total = sum(count)) %&gt;% filter(rank(desc(total)) == 3) ## # A tibble: 1 × 2 ## name total ## &lt;chr&gt; &lt;int&gt; ## 1 Robert 4809858 Or, to find the top three most popular names, replace == in the above by &lt;=. BabyNames %&gt;% group_by(name) %&gt;% summarise(total=sum(count)) %&gt;% filter( rank( desc(total) ) &lt;= 3) ## # A tibble: 3 × 2 ## name total ## &lt;chr&gt; &lt;int&gt; ## 1 James 5114325 ## 2 John 5095590 ## 3 Robert 4809858 When applied to grouped data, rank() will be calculated separately within each group. That is, the rank of a value will be with respect to the other cases in that group. For instance, here’s the third most popular name for each sex. BabyNames %&gt;% group_by(sex) %&gt;% filter(rank(desc(count)) &lt;= 3) ## Source: local data frame [6 x 4] ## Groups: sex [2] ## ## name sex count year ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Linda F 99674 1947 ## 2 James M 94758 1947 ## 3 Robert M 91652 1947 ## 4 Linda F 96210 1948 ## 5 Linda F 90994 1949 ## 6 Michael M 92711 1957 22.1.1 Tied ranks Sometimes, two or more numbers are tied in rank. The rank() function deals with these by assigning all the tied values the same rank, which is the mean of the ranks those values would have had if they were even slightly different. There are other rank-like transformation verbs that handle ties differently. For instance, row_number() breaks ties in favor of the first case encountered. Set %&gt;% mutate(the_rank = rank(numbers), ties_broken = row_number(numbers)) %&gt;% arrange(numbers) ## numbers the_rank ties_broken ## 1 2 1.5 1 ## 2 2 1.5 2 ## 3 4 3.0 3 ## 4 5 4.0 4 ## 5 7 5.0 5 ## 6 8 6.0 6 ## 7 9 7.5 7 ## 8 9 7.5 8 22.2 Leads and lags Set %&gt;% mutate(next_one = lag(numbers, 1)) ## numbers next_one ## 1 2 NA ## 2 5 2 ## 3 4 5 ## 4 7 4 ## 5 2 7 ## 6 9 2 ## 7 9 9 ## 8 8 9 Find the names that increase the most from one year to the next. Let’s take “increase the most” to mean “the biggest proportional increase”, but consider only names that have more than 100 kids in the earlier year. Find proportional increase for each name for each year, but push this to zero if the base year had less than 100 kids. Sharp_increases &lt;- BabyNames %&gt;% group_by(name, year) %&gt;% summarise(births = sum(count)) %&gt;% arrange(year) %&gt;% mutate(change = (births &gt; 100) * lead(births, 1) / births) %&gt;% ungroup() %&gt;% filter(rank(desc(change)) &lt;= 100) %&gt;% arrange(desc(change)) BabyNames %&gt;% filter(name == &quot;Hillary&quot;, sex == &quot;F&quot;) %&gt;% arrange(year) ## name sex count year ## 1 Hillary F 5 1922 ## 2 Hillary F 7 1942 ## 3 Hillary F 13 1943 ## 4 Hillary F 19 1944 ## 5 Hillary F 19 1945 ## 6 Hillary F 29 1946 ## 7 Hillary F 51 1947 ## 8 Hillary F 43 1948 ## 9 Hillary F 48 1949 ## 10 Hillary F 54 1950 ## 11 Hillary F 40 1951 ## 12 Hillary F 43 1952 ## 13 Hillary F 57 1953 ## 14 Hillary F 78 1954 ## 15 Hillary F 71 1955 ## 16 Hillary F 100 1956 ## 17 Hillary F 87 1957 ## 18 Hillary F 94 1958 ## 19 Hillary F 83 1959 ## 20 Hillary F 75 1960 ## 21 Hillary F 111 1961 ## 22 Hillary F 112 1962 ## 23 Hillary F 148 1963 ## 24 Hillary F 132 1964 ## 25 Hillary F 111 1965 ## 26 Hillary F 123 1966 ## 27 Hillary F 155 1967 ## 28 Hillary F 178 1968 ## 29 Hillary F 198 1969 ## 30 Hillary F 258 1970 ## 31 Hillary F 251 1971 ## 32 Hillary F 242 1972 ## 33 Hillary F 250 1973 ## 34 Hillary F 313 1974 ## 35 Hillary F 323 1975 ## 36 Hillary F 331 1976 ## 37 Hillary F 442 1977 ## 38 Hillary F 718 1978 ## 39 Hillary F 921 1979 ## 40 Hillary F 835 1980 ## 41 Hillary F 736 1981 ## 42 Hillary F 752 1982 ## 43 Hillary F 696 1983 ## 44 Hillary F 1009 1984 ## 45 Hillary F 1047 1985 ## 46 Hillary F 1082 1986 ## 47 Hillary F 1080 1987 ## 48 Hillary F 1083 1988 ## 49 Hillary F 1285 1989 ## 50 Hillary F 1524 1990 ## 51 Hillary F 1788 1991 ## 52 Hillary F 2522 1992 ## 53 Hillary F 1064 1993 ## 54 Hillary F 409 1994 ## 55 Hillary F 310 1995 ## 56 Hillary F 312 1996 ## 57 Hillary F 294 1997 ## 58 Hillary F 243 1998 ## 59 Hillary F 253 1999 ## 60 Hillary F 252 2000 ## 61 Hillary F 259 2001 ## 62 Hillary F 197 2002 ## 63 Hillary F 224 2003 ## 64 Hillary F 310 2004 ## 65 Hillary F 285 2005 ## 66 Hillary F 265 2006 ## 67 Hillary F 282 2007 ## 68 Hillary F 412 2008 ## 69 Hillary F 200 2009 ## 70 Hillary F 167 2010 ## 71 Hillary F 166 2011 ## 72 Hillary F 157 2012 ## 73 Hillary F 154 2013 Notice “Woodrow” and “Wilson” in 1911 to 1912. Why? Notice “Samantha” and “Darin” in 1964. Why? (Hint: “Bewitched”) FLAW: There might be years left out for some names. We’ll have to wait until we study joins to see how to fix this. 22.3 Times and Dates With the lubridate package: Transform text dates into an R type with numerical properties. ymd(), dmy(), and so on. Extract parts of the date: day() jday() week() hour() wday() minute() month() year() Holidays &lt;- read.csv(&quot;http://tiny.cc/dcf/US-Holidays.csv&quot;, stringsAsFactors = FALSE) with(Holidays, class(date)) ## [1] &quot;character&quot; Holidays &lt;- Holidays %&gt;% mutate(date = lubridate::dmy(date)) with(Holidays, class(date)) ## [1] &quot;Date&quot; Holidays %&gt;% summarise(middle = mean(date)) ## middle ## 1 1999-11-26 Sys.time() ## [1] &quot;2017-01-24 17:53:44 CST&quot; 22.4 Conditional transforms For all transform verbs, the output depends on some way on the input. In conditional transforms, you use the input to choose one or more possible outputs. One such transform verb is ifelse(). This takes three arguments: 1. a test, written in the form of a “logical”&quot; such as x &gt; 3 2. the output if the test is TRUE 3. the output if the test is FALSE For example, the table below shows measurements made on patients, including the date of the measurement and the date of treatment. A transformation is to be done to say whether the measurement was before or after the treatment. ## Joining, by = &quot;subject&quot; head(Treatments) ## subject what value date treatment_date ## 1 BHO sbp 160 2007-06-19 2012-08-05 ## 2 GWB sbp 115 1998-04-21 2005-11-14 ## 3 BHO sbp 155 2005-11-08 2012-08-05 ## 4 WJC sbp 145 2002-11-15 1998-09-30 ## 5 WJC sbp NA 2010-03-26 1998-09-30 ## 6 WJC sbp 130 2013-09-15 1998-09-30 The calculation of before or after is simple: date &lt; treatment_date.&quot; To render the result as the values &quot;before&quot; and &quot;after&quot;, use ifelse(): Treatments %&gt;% mutate(when = ifelse(date &lt; treatment_date, &quot;before&quot;, &quot;after&quot;)) %&gt;% head() ## subject what value date treatment_date when ## 1 BHO sbp 160 2007-06-19 2012-08-05 before ## 2 GWB sbp 115 1998-04-21 2005-11-14 before ## 3 BHO sbp 155 2005-11-08 2012-08-05 before ## 4 WJC sbp 145 2002-11-15 1998-09-30 after ## 5 WJC sbp NA 2010-03-26 1998-09-30 after ## 6 WJC sbp 130 2013-09-15 1998-09-30 after 22.5 Text Simple operators: tolower() - convert to lower case toupper() - convert to upper case nchar() - the number of characters in a string substr() - extract a substring at a particular location. Example: BabyNames %&gt;% sample_n(size = 5) %&gt;% mutate(small = tolower(name), large = toupper(name), length = nchar(name), middle = substr(name, 2, 3)) ## name sex count year small large length middle ## 1 Christina M 22 1967 christina CHRISTINA 9 hr ## 2 Rotha F 7 1907 rotha ROTHA 5 ot ## 3 Wayman M 9 1997 wayman WAYMAN 6 ay ## 4 Song F 11 1994 song SONG 4 on ## 5 Julian M 535 1948 julian JULIAN 6 ul For later: gsub() grepl() DataComputing::extractMatches() "]
]
